import { Router, Request, Response } from 'express';
import {
  verifyAuth,
  verifyCreatorAccess,
  requirePermissions,
} from '../middleware/auth';
import * as conversationsService from '../services/conversations';
import { ConversationState } from '../types';

const router = Router();

// GET /conversations/creator/:creatorId - Get all conversations for a creator
router.get(
  '/creator/:creatorId',
  verifyAuth,
  verifyCreatorAccess,
  requirePermissions('canViewConversations'),
  async (req: Request, res: Response) => {
    try {
      const { creatorId } = req.params;
      const { state, isHumanTakeover, search, limit, cursor } = req.query;

      const filters: conversationsService.ConversationFilters = {
        creatorId,
        state: state as ConversationState | undefined,
        isHumanTakeover:
          isHumanTakeover !== undefined
            ? isHumanTakeover === 'true'
            : undefined,
        searchTerm: search as string | undefined,
      };

      const pagination = {
        limit: limit ? parseInt(limit as string, 10) : undefined,
        cursor: cursor as string | undefined,
      };

      const result = await conversationsService.getConversations(
        filters,
        pagination
      );
      res.json(result);
    } catch (error) {
      console.error('Error fetching conversations:', error);
      res.status(500).json({ error: 'Failed to fetch conversations' });
    }
  }
);

// GET /conversations/creator/:creatorId/stats - Get conversation statistics
router.get(
  '/creator/:creatorId/stats',
  verifyAuth,
  verifyCreatorAccess,
  requirePermissions('canViewConversations'),
  async (req: Request, res: Response) => {
    try {
      const { creatorId } = req.params;
      const stats = await conversationsService.getConversationStats(creatorId);
      res.json({ data: stats });
    } catch (error) {
      console.error('Error fetching conversation stats:', error);
      res.status(500).json({ error: 'Failed to fetch conversation statistics' });
    }
  }
);

// GET /conversations/:creatorId/:conversationId - Get a single conversation
router.get(
  '/:creatorId/:conversationId',
  verifyAuth,
  verifyCreatorAccess,
  requirePermissions('canViewConversations'),
  async (req: Request, res: Response) => {
    try {
      const { creatorId, conversationId } = req.params;
      const conversation = await conversationsService.getConversation(
        creatorId,
        conversationId
      );

      if (!conversation) {
        res.status(404).json({ error: 'Conversation not found' });
        return;
      }

      res.json({ data: conversation });
    } catch (error) {
      console.error('Error fetching conversation:', error);
      res.status(500).json({ error: 'Failed to fetch conversation' });
    }
  }
);

// GET /conversations/:creatorId/:conversationId/messages - Get messages for a conversation
router.get(
  '/:creatorId/:conversationId/messages',
  verifyAuth,
  verifyCreatorAccess,
  requirePermissions('canViewConversations'),
  async (req: Request, res: Response) => {
    try {
      const { creatorId, conversationId } = req.params;
      const { limit } = req.query;

      const messages = await conversationsService.getMessages(
        creatorId,
        conversationId,
        limit ? parseInt(limit as string, 10) : undefined
      );

      res.json({ data: messages });
    } catch (error) {
      console.error('Error fetching messages:', error);
      res.status(500).json({ error: 'Failed to fetch messages' });
    }
  }
);

// POST /conversations/:creatorId/:conversationId/takeover - Take over a conversation
router.post(
  '/:creatorId/:conversationId/takeover',
  verifyAuth,
  verifyCreatorAccess,
  requirePermissions('canManageConversations'),
  async (req: Request, res: Response) => {
    try {
      const { creatorId, conversationId } = req.params;
      const userId = req.user!.uid;

      const conversation = await conversationsService.takeoverConversation(
        creatorId,
        conversationId,
        userId
      );

      res.json({ data: conversation });
    } catch (error) {
      console.error('Error taking over conversation:', error);
      if ((error as Error).message.includes('not found')) {
        res.status(404).json({ error: 'Conversation not found' });
        return;
      }
      res.status(500).json({ error: 'Failed to take over conversation' });
    }
  }
);

// POST /conversations/:creatorId/:conversationId/release - Release a conversation back to AI
router.post(
  '/:creatorId/:conversationId/release',
  verifyAuth,
  verifyCreatorAccess,
  requirePermissions('canManageConversations'),
  async (req: Request, res: Response) => {
    try {
      const { creatorId, conversationId } = req.params;

      const conversation = await conversationsService.releaseConversation(
        creatorId,
        conversationId
      );

      res.json({ data: conversation });
    } catch (error) {
      console.error('Error releasing conversation:', error);
      if ((error as Error).message.includes('not found')) {
        res.status(404).json({ error: 'Conversation not found' });
        return;
      }
      res.status(500).json({ error: 'Failed to release conversation' });
    }
  }
);

// POST /conversations/:creatorId/:conversationId/messages - Send a message
router.post(
  '/:creatorId/:conversationId/messages',
  verifyAuth,
  verifyCreatorAccess,
  requirePermissions('canManageConversations'),
  async (req: Request, res: Response) => {
    try {
      const { creatorId, conversationId } = req.params;
      const { text } = req.body;
      const userId = req.user!.uid;

      if (!text) {
        res.status(400).json({ error: 'Message text is required' });
        return;
      }

      const message = await conversationsService.sendMessage(
        creatorId,
        conversationId,
        text,
        userId
      );

      res.status(201).json({ data: message });
    } catch (error) {
      console.error('Error sending message:', error);
      if ((error as Error).message.includes('not found')) {
        res.status(404).json({ error: 'Conversation not found' });
        return;
      }
      res.status(500).json({ error: 'Failed to send message' });
    }
  }
);

export default router;
